## C++

### 1. UML

#### 1.1. 类间关系

[图像](../03_tools/01_astah/class_uml.asta)

- **泛化(generalization)**：

  - 直线 空心箭头（继承）

- **实现(realization)**：

  - `虚线 空心箭头`（接口）

  

- **依赖(dependency)**：	   `弱依赖`

  - 虚线 ~~虚~~**实**箭头（参数，静态方法）



- **关联~~合~~(association)**：	`强依赖`
  - `直线` **直**`箭头`（有影响关系）	
- **聚合(aggregation)**：      `强关联`
  - **空菱形** ~~虚~~**直线 直箭头**（多个对象的集合，非同生命周期）
- **组合(composition)**：     `强聚合`
  - **实菱形** **直线** ~~虚~~**箭头**（完全归属，同生命周期）

#### 1.2. 特性

- 斜体类名 抽象类

- property 属性

- operation 方法

### 2. 八股文

#### 2.1. STL

##### 2.1.1. 项目中使用容器的实例：

- 将IP包进行拼接<data design>：
  - 外层：map<iphdr~~_udphdr~~，set，sort() {id_**src**}>
  - 内层：set<*ipdhr&ip_package，sort(){ip.offset}>
- [实例](../eight_legged_essays/ip_assembly/ip_assembly.sln)：
  - **第二次**看，发现**第一次**有和源码理解不同的地方~~A~~ **B**。

#### 2.2. pair

- pair不接受构造型参数，c++17以下不能推导<>
- make_pair，可以自动推导<>
- c++14以下不能auto [1, 2]

#### 2.3. struct：bool&仿函数

- opreator bool()
  - bool值，对象变量var(包括引用)或*ptr形式。
- bool opreator()(xxx)
  - 仿函数，bool operator()(xxx){} ：
    - 普通对象使用
  - 仿函数，bool operator()(xxx) const {} ：
    - const对象使用[sort是const传参]（声明&定义双+），inline，override：声明自己加。
    - 仿函数作为sort传递，调用的时候，会调用**默认构造**，如果构造重载要搞default。

#### 2.4. 错误、警告

- namespace内没有cout：
  - cout错误的放到了函数外，namespace中。

#### 2.5. constructor = default

- construct = default
  - 会初始化成员（ex. int -> 0）。
    - 调用的时候，必须带()
    - [实例](../eight_legged_essays/ip_assembly/constructor.sln)

#### 2.6. thread

- [创建](../eight_legged_essays/muti-thread/muti-thread.sln)
  - 传函数的方式：
    - 仿函数（匿名对象）
    - 类成员（类型::方法，this）
    - lambda
  - 传参数注意点
    - ref -> 变引用（对于引用类型）
    - unique_ptr的move
    - shared_ptr不可传引用（不计数，意外使用nullptr）

#### 2.7. C++11了解哪些说一下

#### 2.8. 设计模式了解哪些说一下

#### 2.9. CPU使用率偏高怎么调查

- top 按1显示各CPU
- taskset 指定CPU

#### 3.0. 内存泄漏怎么调查

- pmap -x
- valgrind
- 测试用例和代码

#### 3.1. 堆越界和栈越界

- 各有什么后果
  - 堆越界有可能coredump，比如堆中存储的指针被修改了，然后又去用这个指针。
    - 读了不该读的，写了不该写的。
    - 堆内存都有嫌疑，就使用哨兵内存裹住使用内存，看谁**溢出来了**【真的有可能，把我忽悠了】。
    - 记录每次操作的地址和长度（对比coredump地址），看看是不是操作了野指针，污染了数据。
- 各自可以怎么预防

#### 3.2. 进程状态

- 初始状态：进程刚被创建，由于其他进程正占有CPU资源，所以得不到执行，只能处于初始状态。

- 就绪状态：只有处于就绪状态的经过调度才能到执行状态

- 等待状态：进程等待某件事件完成

- 执行状态：任意时刻处于执行状态的进程只能有一个（对于单核CPU来讲）。

- 停止状态：进程结束

#### 3.3. 进程和线程

- 进程-操作系统提供的抽象概念，是系统进行**资源分配和调度的基本单位**，是操作系统结构的基础。
  - 程序是指令、数据及其组织形式的描述，进程是程序的实体。
  - 程序本身是没有生命周期的，它只是存在磁盘上的一些指令，程序一旦运行就是进程。
- 线程-也是操作系统提供的抽象概念，是程序执行中一个单一的顺序控制流程，是**程序执行流的最小单元**，是处理器调度和分派的基本单位。
  - 一个进程可以有一个或多个线程，同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈和线程本地存储。 

- 进程 VS 线程

- 进程是资源的分配和调度的独立单元。进程拥有完整的虚拟地址空间，当发生进程切换时，不同的进程拥有不同的虚拟地址空间。而同一进程的多个线程共享同一地址空间（不同进程之间的线程无法共享）
- 线程是CPU调度的基本单元，一个进程包含若干线程（至少一个线程）。
- 线程比进程小，基本上不拥有系统资源。线程的创建和销毁所需要的时间比进程小很多
- 由于线程之间能够共享地址空间，因此，需要考虑同步和互斥操作
- 一个线程的意外终止会影响整个进程的正常运行，但是一个进程的意外终止不会影响其他的进程的运行。因此，多进程程序安全性更高。

#### 3.4. 什么是协程

协程（Coroutine，又称微线程）是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而**完全是由程序所控制**。协程与线程以及进程的关系见下图所示。

- 协程可以比作子程序，但执行过程中，子程序**内部可中断**，然后转而执行别的子程序，在适当的时候再返回来继续执行。协程之间的切换不需要涉及任何系统调用或任何阻塞调用
- 协程只在一个线程中执行，是子程序之间的切换，发生在**用户态上**。而且，线程的阻塞状态是由操作系统内核来完成，发生在内核态上，因此协程相比线程节省了线程创建和切换的开销
- 协程中不存在同时写变量冲突，因此，也就**不需要用来守卫关键区块的同步性原语**，比如互斥锁、信号量等，并且不需要来自操作系统的支持。

**协程适用于IO阻塞且需要大量并发的场景**，当发生IO阻塞，由协程的调度器进行调度，通过将数据流yield掉，并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复协程栈，并把阻塞的结果放到这个线程上去运行。

QA. IO阻塞了，协程怎么还可以动作？

#### 3.5. 如何选择

-  CPU密集型:【多进程】
  - 程序需要占用CPU进行大量的运算和数据处理
-  I/O密集型:【多线程】<一个插座，两个吸尘器>
  - 程序中需要频繁的进行I/O操作：例如网络中socket数据传输和读取等； （协程维护成本较高,而且在读写文件方面效率没有显著提升） 
-  CPU密集+I/O密集：
  - 以上两种的结合【多进程+协程】

#### 3.6. 仿函数

- 仿函数调用，要先生成临时对象；
  - struct cls{}；     =>      cls()(xxx);

#### 3.7. 如何改善hash碰撞

- [链表法](../eight_legged_essays/hashmap/hashmap.sln)

  在拉链法中，装填因子 α 可以大于 1，但一般均取 α ≤ 1。

  装填因子(载荷因子)/hash因子

  散列表的载荷因子定义为：

   α = 填入表中的**元素个数** / **散列表的长度**：2->4->8这种变化，**rehash**，或者**reserve**

  α 是散列表装满程度的标志因子。由于表长是定值，α 与“填入表中的元素个数”成正比，所以，α 越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之，α 越小，标明填入表中的元素越少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是载荷因子α 的函数，只是不同处理冲突的方法有不同的函数。

  对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了荷载因子为0.75，超过此值将resize散列表。
  
