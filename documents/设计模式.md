# 设计模式

- **参考资料**：

  1. 大话设计模式-程杰
  2. 设计模式之禅-秦小波
- 经典观点：

  1. 我们是**面向接口编程**，我们对外公布的是接口而不是实现类。
  2. 做一件事情，或者选择一个方向，一般需要经历三个步骤：
  
     - What——是什么，Why——为什么，How——怎么做
  3. 一个方法的测试方法一般不少于3种，为什么呢？
  
     - 首先是**正常的业务逻辑**要保证测试到
     - 其次是**边界条件**要测试到
     - 然后是**异常**要测试到
  4. 23个设计模式都是从各个不同的角度对**变化（variations）**进行封装
     - 软件设计最大的难题就是应对需求的变化，但是纷繁复杂的需求变化又是不可预料的
     - 6大设计原则 和 23个设计模式都是用来“封装”未来的变化
- 对于学习设计模式的思考：
  - 书中有些观点，无法理解，或者和自己的想法有冲突：
    - 可能是现阶段的基础只是不足（小学生是无法解微积分的），先做mark，等之后有了应用，可以再返回来，看一次。
    - **简单的问题**，学习和实践方法论；**难的问题**，匹配和套用方法论。
  - 投入的精力和铺开的范围有点略大：
    - ？先理解经典例子，再等到开发中遇到同样问题的时候，再去比照。
  - 一时没有明显进步：
    - 可以放到1周搞1篇

## 1. 设计原则

### 1.1. 单一职责原则(SRP)

​	SRP : Single Responsibility Principle

- **定义**
  - 应该**有且仅有**`一个原因`引起**类**的变更。
  - There should never be more than **one reason** for a class **to change**.
    - 一个接口或类只有**一个职责**，它就负责**一件事情**。
  
  - 实例【RBAC模型（Role-Based Access Control)】：
    - **用户信息**    BO（Business Object，业务对象）
    - **用户行为**    Biz（Business Logic，业务逻辑）
  - [实例](../design_pattern/01_simpleFactory_calculator/calculator.sln)【典型SRP类图】：
    - [x] 实现一个计算器类，**属性** 计算数值，**操作** 运算符号。
    - [x] 拆分**属性**和**操作**，为两个interface[bo & biz]。
- 适用**对象**
  - 接口
  - 类
  - **方法**
    - [ ] 一个原因引起变化，失败案例：protocol解析。
    - [ ] 功能清晰且单一，如修改table的某个字段，而非key-value的list形式。

### 2.2. 开闭原则

- **定义**

  - Software entities like classes,modules and functions should be **open for extension** but **closed for modifications**.

    - 一个软件实体如类和抽象、模块和函数应该对扩展开放，对修改关闭。
    - 一个软件实体应该通过**扩展**来**实现变化**，而**不是通过修改**已有的代码来实现变化。

- **优点**

  1. **单元测试**
  
     - 适用扩展的方式修改代码，可以避免对已有的单元测试代码JUNIT的修改。
  
  2. **复用性**
  
     - 在面向对象的设计中，所有的逻辑都是从**原子逻辑组合**而来的，而**不是**在一个**类**中独立实现一个业务逻辑。
     - 只有这样代码才可以复用，**粒度越小**，被复用的可能性就越大。
  
  3. **可维护性**
  
     - 维护人员最乐意做的事情就是**扩展**一个类，而不是**修改**一个类
     - 甭管原有的代码写得多么优秀还是多么糟糕，让维护人员读懂原有的代码，然后再修改，是一件很痛苦的事情
     - 不要让他在原有的代码海洋里游弋完毕后再修改，那是对维护人员的一种**折磨和摧残**。
  
  4. **OOP的要求**
  
     - 万物皆**对象**，我们需要把所有的事物都**抽象**成**对象**，然后针对对象**进行操作**。
  
     - 万物皆**运动**，有运动就有变化，万物皆运动，有运动就有变化。
  
     - 在设计之初**考虑**到所有可能**变化**的因素，然后留下接口，等待“可能”**转变**为“现实”。
  
  - > 实例【书籍打折】：   `有点理解困难：为什么不追加方法，setAcount()`
    
    - **X**修改接口
      - 不良点：
        - `实现类和依赖类都要修改`
        - 因为接口是契约，应该是稳定且可靠的，不应该经常发生变化
    - **X**修改实现类
      - 不良点：
        - 修改price()方法，丢失了原来价格信息
    - **O**创建子类，重写price方法
      - 优点：
        - 对原来的底层代码【类构建】，没有影响
        - 仅需修改，上层代码【类注册】，是必要的
        - 开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行**耦合**，否则就是一个孤立无意义的代码片段
  
- **使用**

  1. 抽象约束：
     - 第一，通过**接口或抽象类约束扩展**，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；
     - 第二，**参数类型、引用对象**尽量使用**接口**或者**抽象类**，而不是实现类；
     - 第三，**抽象层**尽量保持**稳定**，一旦确定即不允许修改。
     - > 实例【添加计算机书籍，要求增加获取类别的方法，原来是小说】
       
       - **X** 修改interface，除非重构代码，否则**不能修改interface**，而且，还会影响其他使用interface的模块。
       - **X** 实现类中添加方法，不能使用多态了。
       - **O** 添加子interface，追加方法。
     
  2. 元数据（metadata）控制模块行为
     - 编程是一个很苦很累的活，那怎么才能减轻我们的压力呢？
       - 使用元数据来控制程序的行为，减少重复开发。
     - 什么是元数据？
         - 用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。
     - 修改子类，修改配置文件，完成业务变化。（spring）
     
  3. 制定项目约束
  
     - 所有开发人员安装统一的标准编程
  
  4. 封装变化
  
     - 第一，将**相同**的变化（**variations**/变量）封装到一个**接口**或**抽象类**中；
     - 第二，将**不同**的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。

## 2. 设计模式

### 2.1. 简单工厂模式

[实例]((../design_pattern/01_simpleFactory_calculator/calculator.sln))

- **计算器**

  - 面向接口编程
  - SRP & OC
  - 简单工厂模式

- **构造过程(-优化-)**

  1. 不直接使用函数
     - 使用类【java就没有独立函数】
  
  2. 不直接使用错误返回值
     - 抛出异常，使用catch throw
  
  3. 不直接定义类对象
     - 使用继承和多态【up**复用**，up**扩展**】
     - 面向接口编程
  
  4. 对照设计原则
     - 单一职责原则【**活字印刷术，曹操变需求**】
     - 开闭原则
  
- **期间问题**

  1. **const引用参数，不能调用非const方法**
  - const**对象**，只能访问const**方法**，是一种**函数重载**形式
     - const修饰的成员**函数**，**不能**修改任何的**成员变量**，**不能**调用**非const函数**，且只能被**const对象调用**
     
2. *ptr_cls = a 使用的是**等号赋值**，非**指针**指向
  - 如果ptr_cls未赋值，行为未知（same with**普通指针操作**）
     
  3. **接口**的**析构为虚**
- 不然无法析构多态对象，**父类~()**需要为**virtual**
     
  4. 应对operator data类型变化，使用**模板参数**
  
   - **所有使用<T>**的地方，哪怕作为参数使用，也**要添加template声明**
     - 类的**方法**的模板参数定义和**类**的**模板参数定义**相同，都是**限定作用域**
   - 类中，如果只有成员方法使用<T>，可以**只为function添加template声明**